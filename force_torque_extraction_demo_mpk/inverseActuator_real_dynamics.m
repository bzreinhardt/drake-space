% TEST_inverseActuator
%Question: how long would it take to generate a loookup for each state?
%Do this over all possible velocities, distances, 

n = 5;
u_max = 10000; %rad/s
u_min = -u_max;
%grid of possible inputs
ui = repmat(linspace(u_min,u_max,n),[6,1]);

%Generate a target force
xTarget = -1.5 + 3*rand(1);
yTarget = -1.5 + 4*rand(1);
zTarget = 0 + 1*rand(1);
fTarget = [xTarget;yTarget;zTarget];  %Target Force


%% This is the part that doesn't scale well for multiple dimensions
[U1, U2, U3, U4, U5, U6] = ndgrid(ui(1,:),ui(2,:),ui(3,:),ui(4,:),ui(5,:),ui(6,:));
% u is a 2xn*n vector of all the possibible (discretized) input combinations
% I suspect this ceases to work 
u = [reshape(U1,1,n*n); reshape(U2,1,n*n)];
cost = objective(u,fTarget);
[~,idx] = min(cost,[],2);

%% Generate Actuator Function based on state
%% Generate Power function based on state
%%

%closest u in u grid
uGuess = u(:,idx);
% foce generated by closest u
fGuess = actuator(uGuess);


Problem.x0 = uGuess;
Problem.objective = @(u)objective(u,fTarget);
Problem.Aeq = [];
Problem.beq = [];
Problem.Aineq = [];
Problem.bineq = [];
%limits on u
Problem.lb = [-1;-1];
Problem.ub= [1;1];
Problem.options = optimset();
Problem.solver = 'fmincon';
% minimize difference between the generated force and the actual force
uSoln = fmincon(Problem);
fSoln = actuator(uSoln);

%% Generate error
err = fTarget-fSoln;
norm_err = norm(fTarget-fSoln);
err_max = 0.1; 
if norm_err > err_max
    warning('Cannot find control close enough to desired control');
end
%power = power(uSoln);

%%

% figure(1337); clf; hold on;
% plot3(fTarget(1),fTarget(2), fTarget(3),'rx','MarkerSize',15,'LineWidth',4)
% plot3(fGuess(1),fGuess(2), fGuess(3),'go','MarkerSize',20,'LineWidth',4)
% plot3(fSoln(1),fSoln(2), fSoln(3),'bx','MarkerSize',15,'LineWidth',4)
% plotActuator();
% xlabel('x');
% ylabel('y');
% zlabel('z');
% legend('Target','Guess','Soln');

%% Visualize ball of potential forces for a given state
